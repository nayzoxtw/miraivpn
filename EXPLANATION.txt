1. Project Overview

MiraiVPN is a VPN service platform that allows users to purchase and manage VPN subscriptions through a web interface, with automated WireGuard configuration generation and Discord bot support for customer service. The platform consists of a Next.js frontend for user interaction, a PHP backend API for business logic and database operations, a Discord bot for support tickets and monitoring, and a MySQL database for data persistence. The overall architecture follows a microservices approach where the frontend communicates with the private PHP API via HTTPS, the bot interacts with the database for ticket management, and deployment is handled through a Windows batch script that builds and deploys to a VPS. Security principles include private API access with X-API-KEY headers, JWT tokens for authenticated sessions, rate limiting to prevent abuse, CORS restrictions to allowed origins only, and HTTPS enforcement throughout. All sensitive operations like payments and configuration generation are protected by multiple layers of validation.

2. Frontend (Next.js / TypeScript)

The frontend is built with Next.js and TypeScript, located in the src/ directory. It communicates with the PHP backend through API calls to endpoints like /backend/api/auth/register and /backend/api/stripe/checkout, using environment variables NEXT_PUBLIC_API_URL and NEXT_PUBLIC_API_KEY for configuration. Key pages include the marketing homepage at src/app/(marketing)/page.tsx showing features and stats, pricing page at src/app/pricing/page.tsx displaying subscription plans, servers page at src/app/servers/page.tsx listing available VPN locations, authentication pages like src/app/register/page.tsx and src/app/login/page.tsx, and support pages like src/app/faq/page.tsx. Stripe checkout integration is handled in src/app/api/stripe/checkout/route.ts which creates payment sessions and redirects to /thanks page, while WireGuard configuration download is managed through the VPS controller. The application supports multiple languages through a simple translation system and is fully responsive using Tailwind CSS for styling across mobile and desktop devices.

3. Backend (PHP Private API)

The backend is a PHP-based private API located in the backend/ directory, with dependencies managed through composer.json including libraries for JWT, Stripe, and database connections. The file structure includes controllers like AuthController.php for user registration, email verification, login, token refresh, and password reset operations; StripeController.php for handling checkout sessions and webhook events; VPSController.php for server status checks, subscription confirmation, and WireGuard configuration generation; and supporting files like Middleware.php for request processing. The database schema includes tables for users (storing credentials and credits), subscriptions (linking users to plans and servers), vps_servers (tracking server health and load), wireguard_peers (managing VPN connections), and others for sponsorships and credit tracking. MySQL migrations are handled through the sql/001_init.sql file which creates tables with IF NOT EXISTS clauses for idempotency. API security requires X-API-KEY headers for all requests except Stripe webhooks, JWT tokens for protected endpoints, and HTTPS-only access. Email functionality uses Resend API for verification and password reset emails, while Stripe integration handles subscription creation with metadata for user identification and webhook processing for payment confirmations. VPS balancing logic selects servers based on load and region preferences, with quota tracking updating usage statistics in real-time.

4. Discord Bot (JavaScript / discord.js)

The Discord bot is implemented in JavaScript using discord.js, with code located in the src/bot/ directory. Its primary role is to provide customer support and monitor service status within the MiraiVPN ecosystem, connecting to the same MySQL database as the backend for persistent ticket and staff state management. Implemented commands include /status for displaying server health, /staff commands for managing support team availability (count, list, toggle), and /ticket system for user support requests (open, close, claim). The ticket system follows a flow where users first interact with FAQ auto-help responses from flows.json, then escalate to human staff if needed, with staff able to claim and resolve tickets. Site monitoring is performed through cron-based ping checks that update server status and bot presence. The bot includes anti-spam measures, rate limiting on commands, and comprehensive error handling with logging. Database connections use Prisma for type-safe queries on ticket and staff tables.

5. Database (MySQL)

The database runs on MySQL and is hosted at sql.miraivpn.com, with connection settings configured through environment variables in the backend .env file. Tables include users for account information and credits, verification_tokens for email confirmation, subscriptions linking users to VPN plans and servers, vps_servers for server monitoring data, wireguard_peers for VPN connection tracking, sponsorships for referral rewards, credit_ledger for transaction history, and stripe_events for webhook processing. The Prisma schema in prisma/schema.prisma mirrors the MySQL structure but is used for the bot's database operations, while the backend uses direct MySQL queries. Data flows from user registration creating a users record, through subscription creation linking to vps_servers, to wireguard_peers being generated for active connections. All tables use appropriate foreign keys and indexes for performance, with the system designed for high availability and concurrent access.

6. Deployment System (Windows â†’ VPS)

The deployment system consists of several files: deploy.bat for the main Windows batch script, .env.deploy for environment configuration, server/nginx_miraivpn.conf for web server setup, server/ecosystem.config.js for bot process management, and docs/DEPLOY_WINDOWS.md for documentation. The deploy.bat script performs pre-flight checks for required tools like Node.js, npm, PHP, and Composer, then builds the frontend with npm run build, installs backend dependencies with composer install, packages the bot, and creates a timestamped ZIP artifact. It securely uploads to the VPS using PSCP, extracts files, runs database migrations from backend/sql/001_init.sql, switches symlinks for zero-downtime deployment, and reloads Nginx and PHP-FPM services. The system maintains 5 latest backups and supports rollback to previous versions. Flags include --dry-run for testing without execution and --provision for initial server setup. Logs are written to deploy-logs/ directory, and Nginx serves both frontend static files and backend PHP endpoints through fastcgi_pass to php8.3-fpm.sock. PM2 manages the bot process with the miraivpn-bot name, ensuring automatic restarts and health checks. All operations are designed to be idempotent and safe for repeated execution.

7. Security & Best Practices

Private API access is enforced through X-API-KEY headers required on all requests except Stripe webhooks, with keys validated in Middleware.php. JWT tokens are used for authenticated sessions with 15-minute expiration and refresh capabilities, stored securely in HTTP-only cookies. Rate limiting prevents abuse by tracking requests per IP with a 10-requests-per-minute limit using in-memory storage. HTTPS is enforced through Nginx configuration and .htaccess redirects, with CORS restricted to allowed origins like the main domain and localhost for development. Stripe webhooks are verified using webhook secrets and processed idempotently to prevent duplicate charges. Database security uses prepared statements and password hashing with bcrypt, while WireGuard configurations are generated server-side and never exposed in logs. Backup rotation keeps only recent versions, and recommendations include Fail2ban for SSH protection and Cloudflare for DDoS mitigation and SSL termination. File system security blocks access to sensitive directories like vendor/ and sql/ through Nginx deny rules.

8. How to Modify or Extend the Project

To add a new API endpoint, create a new method in the appropriate controller file like VPSController.php, define the route in the switch statement of backend/public/index.php, and ensure it uses the Middleware for authentication and rate limiting. For new frontend pages, create a new directory in src/app/ with page.tsx and add navigation links in components/layout/Navbar.tsx, using the API functions from src/lib/api.ts for backend communication. Discord bot commands can be added by creating new files in src/bot/commands/ following the existing pattern, registering them in register-commands.js, and updating the database schema if needed. To connect a new VPS region, add server details to configs/servers.public.json and update the VPSController.php balancing logic. Payment plans are modified in src/lib/plans.ts and backend logic, while quotas are tracked in the subscriptions table. Email templates are edited through the Resend dashboard using the templates referenced in Mailer.php. Design customization involves updating Tailwind classes in component files and replacing assets in public/ directory, with branding changes requiring updates to logos and color variables in globals.css.

9. Developer Notes / Next Steps

Several areas remain to be tested including full end-to-end payment flows, WireGuard configuration downloads under load, and bot ticket escalation performance. Code optimizations could include implementing Redis for session storage and rate limiting, adding database connection pooling, and caching frequently accessed server status data. Future features might include a mobile app for iOS/Android, advanced analytics dashboard with usage graphs, user profile management with subscription history, and automated server scaling based on demand. Deployment improvements could involve Docker containerization for easier environment consistency, GitHub Actions for CI/CD pipelines with automated testing, and Terraform for infrastructure as code. Monitoring enhancements might include Grafana dashboards for system metrics, Prometheus exporters for application performance, and Sentry for error tracking. The architecture could benefit from API versioning for backward compatibility and GraphQL for more flexible frontend queries. Database performance might be improved with read replicas and query optimization for large user bases.
